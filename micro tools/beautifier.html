<!doctype html>
<meta charset=utf-8>
<body id=b>

<script type=tests id=testspack>for(_='")Zfunction(a,h){Y/,YX.replace(/W?jWV\\UUd+S|[^R"==QvalP*?GinF++}):E/g,"DD$1Cse|B.Pue/g,Y=[];])@@=j *);jW"D $1 [h]}Qh[0]^;]G;[Un([return Array(dU/C$2Us*.push(a);"	Xs	s"+g++}(UUUU|UU).joF("  Z+a(U+U+|--).match(/(S) )(cS)*/m).FnerHTML+="<textarea style=width:98%;height:48vh id=bp>"+_;bq>";(onFput=Yj=p;(zWePU((.)U)$/,"j=$1Z)!&&eP(z);csre=f=g=o=0;for(d=1;o!;)o,"/Q(k[\'"]/))?(l.FdexOf(k),n.slice(0,l+1),j[l+1][*]$/)V.*|U*[^]GU*Xc	c"+eE!nUdU)U]U}]|true|falBnull|undefFed|this|sS&&n-,;=><+%*&|^~!?!:U[U({]|delete|void|F|caBelB|d|^VR+?Uw*Xr	r"+fEjW/,"dZ):j="\'QkV\'\'R\'G\'):jW""R"G"dD/(=+|[-+*%=&|:?<>^!]+),D, }D}([;{}]|(caBdefault).G:)C(Uw)(Uw|U))[Ur]+DforU^] aWDZW;D; Z} +D .G{}?h+="";if("{)++;"}&&d--;})}U]]|if|while|Ud)({[,;)({[}-+Uw]*)(}|[)U]C$2$3!D!{ !C!(|)Dccssrr[h]});q})()';g=/[^ -AH-OT[-~]/.exec(_);)with(_.split(g))_=join(shift());eval(_)</script>


<script type=tests id=tests>if ('this_is'==/an_example/){of_beautifier();}else{var a=b?(c%d):e[f];}
for (var line=1; line<30; line++) {
for(var i=1;i<29;i++) {
var s = (Math.floor((Math.random()*2)%2)) ? "?" : "?";
document.write(s);
document.writeln("<br>");
}}
{a:1, b:2}
var a=1, b=c[d], e=6;
for(var a=1,b=2,c=3;d<3;d++)e
for(var a=1,b=2,c=3;d<3;d++)e
function foo() {    return [        "one","two"    ];}
a=[[1,2],[4,5],[7,8]]
a=[[1,2],[4,5],[7,8],]
a=[[1,2],[4,5],function(){},[7,8]]
a=[[1,2],[4,5],function(){},function(){},[7,8]]
a=[[1,2],[4,5],function(){},[7,8]]
a=[b,c,function(){},function(){},d]
a=[b,c,function(){},function(){},d]
a=[a[1],b[4],c[d[7]]]
[1,2,[3,4,[5,6],7],8]
[[["1","2"],["3","4"]],[["5","6","7"],["8","9","0"]],[["1","2","3"],["4","5","6","7"],["8","9","0"]]]
if(p) foo(a,b);
try{while(true){willThrow()}}catch(result)
switch(result){case 1:++result }
((e/((a+(b)*c)-d))^2)*5;
function f(a,b) {if(a) b()}function g(a,b) {if(!a) b()}
a=[];
a=[b,c,d];
a= f[b];

async function foo() {}
let w = async function foo() {}
async function foo() {}var x = await foo();
wrapper(async function foo() {})
async function() {    var w = await(async function() {        return await foo();    })();}
async.map(function(t) {})
var a =  1;/* beautify preserve:start */   var a = 1;/* beautify preserve:end */
var a = 1; /* beautify preserve:start */   var a = 1;/* beautify preserve:end */
a=typeof(x)
x();function(){}
x();var x = {x: function(){}}
function () {    var a, b, c, d, e = [],        f;}
switch(x) {case 0: case 1: a(); break; default: break}
switch(x){case -1:break;case !y:break;}
fragment: true,
var a2, b2, c2, d2 = 0, c = function() {}, d = '';
var a2, b2, c2, d2 = 0, c = function() {},d = '';
var o2=$.extend(a);function(){alert(x);}
function*() {    yield 1;}
(function() {if (!window.FOO) window.FOO || (window.FOO = function() {var b = {bar: "zort"};});})();
if(x){a();}else{b();}if(y){c();}
if (x) {
    a();
} else {
    b();
if (y) {
    c();
}}

a        =          1
a=1
["a", "b"].join("")
var a = 1 var b = 2
var a=1, b=c[d], e=6;
let a = 1 let b = 2
let a=1, b=c[d], e=6;
const a = 1 const b = 2
const a=1, b=c[d], e=6;
if(1){2}else{3}
if(1||2);
(a==1)||(b==2)
var a = 1 if (2) 3;
/12345[^678]*9+/.match(a)
a<.5
a<=.5
a=0e-12345.3e-10
a=0.e-12345.3e-10
a=0x.e-12345.3e-10
a=0x0.e-12345.3e-10
a=0x0.0e-12345.3e-10
a=0g-12345.3e-10
a=0.g-12345.3e-10
a=0x.g-12345.3e-10
a=0x0.g-12345.3e-10
a=0x0.0g-12345.3e-10
a=030e-5
a=00+4
a=32+4
a=0.6g+4
a=01.10
a=a.10
a=00B0x0
a=00B0xb0
a=00B0x0b0
a=0090x0
a=0g0b0o0
a=0x30e-5
a=0xF0+4
a=0Xff+4
a=0Xffg+4
a=0x01.10
a=0x0B0x0
a=0x0B0xb0
a=0x0B0x0b0
a=0X090x0
a=0Xg0b0o0
a=0o30e-5
a=0o70+4
a=0O77+4
a=0O778+4
a=0O77a+4
a=0o01.10
a=0o0B0x0
a=0o0B0xb0
a=0o0B0x0b0
a=0O090x0
a=0Og0b0o0
a=0b10e-5
a=0b10+4
a=0B11+4
a=0B112+4
a=0B11a+4
a=0b01.10
a=0b0B0x0
a=0b0B0xb0
a=0b0B0x0b0
a=0B090x0
a=0Bg0b0o0

F*(g/=f)*g+b
a.b({c:d})
a.b({c:d})
a.b({c:"d"})
a.b({c:"d"})
a=!b
a=!!b
a?b:c
a?1:2
a?(b):c
x={a:1,b:w=="foo"?x:y,c:z}
x=a?b?c?d:e:f:g;
x=a?b?c?d:{e1:1,e2:2}:f:g;
function void(void) {}
if(!a)foo();
a=~a
a;/*comment*/b;
a;/* comment */b;
a;/*** javadoc*/b;
a;/** javadoc*/b;
if(a)break;
if(a){break}
if((a))foo();
for(var i=0;;) a
for(var i=0;;)a
for(;;i++)a()
for(;;i++)a()
for(;;++i)a
return(1)
try{a();}catch(b){c();}finally{d();}
(xx)()
a[1]()
if(a){b();}else if(c) foo();
switch(x) {case 0: case 1: a(); break; default: break}
switch(x){case -1:break;case !y:break;}
a !== b
if (a) b(); else c();

$http().then().finally().default()
$http().when.in.new.catch().throw()
{xxx;}()
{/abc/i.test()}
var x=(a)/a;
for (; s-- >0;)t
for (; s++>0;)u
a = s++>s--;
a = s++>--s;
{x=#1=[]}
{a:#1={}}
{a:#1#}
{a:#1=[],b:#1#,c:#999999#}
do{x()}while(a>1)
x(); /reg/exp.match(something)
function namespace::something()
{foo();--bar;}
{foo();++bar;}
{--bar;}
{++bar;}
if(true)++a;
if(true)++a;
if(true)--a;
if(true)--a;
a=[[1,2],[4,5],[7,8]]
a=[[1,2],[4,5],function(){},[7,8]]
a=[[1,2],[4,5],function(){},function(){},[7,8]]
a=[[1,2],[4,5],function(){},[7,8]]
a=[b,c,function(){},function(){},d]
a=[b,c,function(){},function(){},d]
a=[a[1],b[4],c[d[7]]]
[1,2,[3,4,[5,6],7],8]
[[["1","2"],["3","4"]],[["5","6","7"],["8","9","0"]],[["1","2","3"],["4","5","6","7"],["8","9","0"]]]
{[x()[0]];indent;}
return [1,2]
catch(e)
var a=1,b={foo:2,bar:3},{baz:4,wham:5},c=4;
var a=1,b={foo:2,bar:3},{baz:4,wham:5},c=4;
function x(/*int*/ start, /*string*/ foo)
/*** foo*/
{/*** foo*/}
{/**foo*/}
{/**foo**/}
{/**foobar**/}
{/**foobar**/}
{/**foo    bar**/}
var a,b,c=1,d,e,f=2;
var a,b,c=[],d,e,f=2;
do/regexp/;while(1);
var a = a,a;
a=typeof(x)
var whatever = require("whatever");function() {    a = 6;}
var whatever = require("whatever")function() {    a = 6}
{"x":[{"a":1,"b":3},7,8,8,8,8,{"b":99},{"a":11}]}
{"x":[{"a":1,"b":3},7,8,8,8,8,{"b":99},{"a":11}]}
{"1":{"1a":"1b"},"2"}
{a:{a:b},c}
{[y[a]];keep_indent;}
if (x) {y} else { if (x) {y}}
var a=1,b={bang:2},c=3;
var a={bing:1},b=2,c=3;
1;
// comment

// comment with "string" 'string' /regex/ slash: /, doubleslash: //, quotes: "', /*comment*/ anything: \\\/////\/\//////\\\n

/* comment */

/* multiline
comment */

2;

'';

'string';

"string";

"escaped\"doublequote";

'escaped\'quote';

"not escaped doublequote \\";

'not escaped quote \\';

' string with quotes ", escapes: \', /regex/, /* comments */, // comments'

"string with quotes ', escapes: \", /regex/, /* comments */, // comments"

"\\\\"

'\\\\'

"escaped \
newline"

'escaped\
newline'

3;

1/2

a / b

4;

/regex/;

/regex/gumiy;

/regex with \/ escape \\\/ escape "string" 'string'/;

/ /;

/\\\\/;

// /[a/b]/


5;

/0//0

/1/ /regex/ /"string/"// <-- comment starts here /

0/ /regex//1// <-- comment starts here

/2/ /* comment *//1/g// <-- comment starts here

</script>



<script>
_=testspack.innerHTML;



// MINI JS BEAUTIFIER

// This is a 1kb JavaScript (ES5) beautifier able to process normal, minified or RegPacked JS code and make it as readable as possible.
// As there's no room for a real JS parser / AST builder, it relies only on regular expressions tests and replaces.
// The main challenge when modifying JS code is to never affect the content of /*comments*/, "strings" or /regular expressions/.
// So the idea is to extract comments, strings and regexes before beautifying the rest of the JS code, and put them back later.
// Though, these elements are ambiguous. For example, it's hard to tell:
// - if a slash (/) is the start or the end of a comment or a regex, a division sign, or just a character in the middle of a string, a comment or a regex.
// - if a quote or double-quote is the start or the end of a string, or just a character in the middle of a string, a comment or a regex.
// - if an antislash is used as a character or in an escape sequence in a var name, a string, a comment or a regex.
// Here's the solution I found:
// - Make a loop, and at each iteration, see which character (slash, quote or double quote) comes first,
// - Use the characters around to decide if it's a division sign or the start of a string, a regex, or a comment,
// - Then isolate the string / regex / comment / divisor sign, and replace it temporarly with a token.
// - Repeat until no more slashes or (double-)quotes are found.
// - The tokens will be replaced with their original at the end of the script.

// Add the textareas in the page (input/output)
// As a demo, the app beautifies its own minified source code, contained in the variable "_"
b.innerHTML += "<textarea style=width:98%;height:48vh id=p>" + _;
b.innerHTML += "<textarea style=width:98%;height:48vh id=q>";

// When JS sode is typed / pasted in the textarea:
(oninput = function(a,b){

  // Read the JS code to beautify
  j = p.value;

  // Unpack regpacked code:
  // If the code ends with /eval(.)/, execute everything before the eval and store the result in j
  if((z = j.replace(/eval\((.)\)$/, "j=$1")) != j){
    eval(z);
  }

  // Identify comments, regexes and divisions:
  c = []; // comments
  s = []; // strings
  r = []; // regexes
  e = f = g = // counters
  o = 0; // Code backup
  d = 1; // Indentation


  // Loop while the code is changed inside the loop
  for(; o !=j; ){

    // Backup js code
    o = j;

    // Find first quote, double quote or slash in the code
    
    // and if it's a slash:
    if((k = j.match(/['"\/]/)) == "/"){

      // Take all the chars preceding the slash
      l = j.indexOf(k);
      n = j.slice(0,l+1);
      
      // Identidy a comment if the slash is followed by "/" or "*"
      if(j[l + 1].match(/[\/*]$/)){
        j = j.replace(/\/\/.*|\/\*[^]*?\*\//, function(a,b){
          c.push(a);
          return "@@c" + (e++);
        });
      }
      
      // Identify a regex:
      // - if we're sure the slash is not a division sign
      // (it's a division if slash follows a digit, a variable, a boolean, ")",  "}", "]", null, undefined, this (plus optional spaces / line jumps / comments))
      // - or if we're sure it's a regex
      // (It's a regex if the slash is at the start of the js code or follows an operator, ",", ";", "[", "(", "{", case, delete, else, return, return (plus optional spaces / line jumps / comments):
      // Improbable operators and keywords (those who are never actually used before a regex) are ignored
      else if(
        !n.match(/([\d\)\]\}]|true|false|null|undefined|this|@@s\d+)\s*(@@c\d+)*\s*\//m)
        && n.match(/([-,;=><+%*&|^~!?!:\[\({]|delete|void|in|case|else|return|@@d|^)\s*(@@c\d+)*\s*\//m)
      ){
        j = j.replace(/\/(\\\\|\\\/|[^\/])+?\/\w*/, function(a,b){
          r.push(a);
          return "@@r" + (f++);
        });
      }
      
      // Else, assume it's a division sign
      else {
        j = j.replace(/\//, "@@d");
      }
    }
    
    // Isolate strings, including escape sequences
    // Single quotes
    else if(k == "'"){
      j = j.replace(/'(\\\\|\\'|[^'])*?'/, function(a,b){
        s.push(a);
        return "@@s" + (g++);
      });
    }
    
    // Double quotes
    else{
      j = j.replace(/"(\\\\|\\"|[^"])*?"/, function(a,b){
        s.push(a);
        return "@@s" + (g++);
      });
    }
  }
  
  // Put back the division signs
  j = j.replace(/@@d/g, "/");
  
  // Now the comments, strings and regexes are extracted and replaced with @@ tokens, and the rest of the code can be beautified: 

  // Ensure there are spaces around strings, operators ( /, +, -, *, %, =, &, |, :, ?, <, >, ^, !) and composed operators, (>>=, ...)
  // (but do not compose "=" with other operators, only with itself. ex: "a=!b" becomes "a = ! b", "a===b" becomes "a === b")
  j = j.replace(/ *(=+|[-+*%=&|:?<>^\/!]+) */g, " $1 ");

  // Ensure there are spaces after ","
  j = j.replace(/ *, */g, ", ");

  // Ensure there are line jumps after "}"
  j = j.replace(/}/g, "\n}");

  // Ensure there are line jumps after ";", "{", "}", "case ...:" and "default :"
  j = j.replace(/( *[;{}]|(case|default).*?:) */g, "$1\n");
  
  // Fix spaces around ++ / -- operators
  j = j.replace(/ *(\+\+|--) */g, " $1 ");
  j = j.replace(/(\w) *(\+\+|--)/g, "$1$2");
  j = j.replace(/(\+\+|--) *(\w|\))/g, "$1$2");

  // Clean line breaks
  j = j.replace(/[\r\n]+ */g, "\n");

  // Put for loops on one line and ensure there are spaces after the two ";" inside
  j = j.replace(/for\s*\([^;]*?;[^;]*?;[^]/g, function(a,b){
    return a.replace(/\n/g, "").replace(/;/g, "; ");
  })

  // Clean spaces
  j = j.replace(/ +/g, " ");
  
  // Reindent all the lines
  j = j.replace(/.*?([{}])?\n/g, function(a,b){
  
    // Ensure the match is a string (if it's undefined, that makes an empty string)
    b += "";
    
    // After an "{", indent with two more spaces
    if(b[0] == "{"){
      return Array(d++).join("  ") + a;
    }
    
    // After a "}", unindent
    else if(b[0] == "}"){
    
      // Uncomment the next line to ensure the indentation is never negative (should only happen on malformed code)
      // d && 
      d--;
    }
    
    return Array(d).join("  ") + a;
  });

  // Remove spaces and line breaks between "{", "[", "(", ")", "]", "}", ",", ";", ":"
  j = j.replace(/([)}\]]|if|while|\d)\s*([({[,;)])/g, "$1$2");
  j = j.replace(/([({[}])\s*([-+\w]*)\s*(\s*}|[)\]])/g, "$1$2$3");
  j = j.replace(/!\s*/g, "!");
  j = j.replace(/([([{]) !/g, "$1!");

  // Clean line breaks and empty lines
  j = j.replace(/\n( *\n|\n)/g, "\n");

  // Put back comments
  j = j.replace(/@@c(\d+)/g, function(a,b){
    return c[b]
  });

  // Put back strings
  j = j.replace(/@@s(\d+)/g, function(a,b){
    return s[b];
  });

  // Put back regexes
  j = j.replace(/@@r(\d+)/g, function(a,b){
    return r[b]
  });

  // Output
  q.value = j;

})();


// Final compression:
// - Closure Compiler, advanced mode.
// - Remove line spaces, remove trailing semicolon, put the two parameters (a,h) in all the functions definitions. => 1812b.
// - RegPack with all checkboxes unchecked and score = 2 / 1 / 0 => 1022b.
// Regpack puts the minified code in the variable "_" and evaluates it. (this "_" is the one used in the textarea)



</script>


